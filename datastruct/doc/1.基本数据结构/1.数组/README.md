# 数组

## 介绍

- **连续**的内存空间，来存储一组具有**相同类型**的数据

    ![](./picture/数组内存图.jpg)

    - 上图中内存块的首地址为 baseAddress = 1000
    - a[i]address = baseAddress + i * dataTypeSize
        - int 类型的数据占四个字节，所以这里的 dataTypeSize=4

- 数组支持随机访问，根据**下标随机访问**的时间复杂度为 O(1)
    
    - 注意：“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)”。实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)

- 插入和删除数据比较低效
    
    - 假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位

- 优化1：直接交换
    
    - 我们现在需要将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2] 赋值为 x 即可。最后，数组中的元素如下： a，b，x，d，e，c。

    ![](./picture/数组插入-交换.jpg)

- 优化2：删除数据使用标记法
    
    - 数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。
    
    ![](./picture/数组插入-标记删除.jpg)


### 警惕数组越界
