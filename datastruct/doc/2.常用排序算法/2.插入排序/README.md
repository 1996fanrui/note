# 插入排序

## 介绍

- 一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可

	![](./picture/插入排序原理.jpg)

- 将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

	- 排序过程图示

	![](./picture/插入排序过程.jpg)

- 插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入

- 排序分析

	- 空间复杂度
		
		代码中来看，只需要保存一个value，所以空间复杂度 O(1)

	- 时间复杂度

		- 我们在数组中插入一个数据的平均时间复杂度是 O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n<sup>2</sup>)。
		
		- 如果数据本来就是有序的，最好时间复杂度O(n)

	- 稳定的排序算法

- 优化

	- 跳过最长的升序序列
		
		- 从第一个降序处开始排序
	
	- 二分插入排序(TimSort使用到)

		- 通过二分查找，在已排序区间快速找到数据应该插入的位置
		
		- 减少比较次数，并没有减少数据移动的次数

	- 成对插入排序 - pair insertion sort（DualPivotQuicksort使用到）
		
		- 每次插入两个数据到已排序的区间，减少了移动次数
		
		- 1,2,3,4,5,6,7,8,9,10,11,12,1,2
		
		- [3-12]直接向后移动两位，2向后移动一位，插入1、2

		- 疑问？利用成对排入排序的思路，是否可以每次插入十个元素？
			
			- 成对插入排序的，需要有个前提条件，先给两个数中较大的值找到位置，再给较小的值找到位置，这样大数之后的数只需要移动一次即可。这里，如果每次插入十个数，需要找到十个数中最大的数，再找到次大的数，再依次找后续大的数，意味着，需要对要插入的十个数进行排序，排序需要消耗时间，所以每次插入十个元素不一定能提高效率，有可能节省的移动次数很少，但是对十个数排序耗费了不少时间

- 同样是O(n<sup>2</sup>)，插入排序为何如此优秀？

	- 比较次数

		- 冒泡排序

			- 不考虑提前结束的情况，比较次数为 n+(n-1)+(n-2)+…+1= n<sup>2</sup>/2

		- 插入排序

			- 平均情况下，每轮比较都是冒泡排序比较次数的一半，所以最终的比较次数为 n<sup>2</sup>/4

			- 若使用二分查找来优化，比较次数最多为 O(n log n)

	- 交换次数

		- 无论冒泡还是插入排序，每交换一次相邻数据，逆序度减1，所以两种算法的交换次数相同（没有优化的情况）

		- 冒泡排序每次交换操作需要进行三次赋值操作
		
		- 插入排序每次交换操作需要进行一次赋值操作

		- 插入排序使用pair insertion sort，交换次数会明显减少

	- 插入排序可以优化为`二分插入排序` 或者 `成对插入排序`，性能会比冒泡排序高效很多


[普通插入排序代码实现](../../../src/main/java/fanrui/study/sort/InsertSort.java)

[binaryInsertionSort代码实现](../../../src/main/java/fanrui/study/sort/BinaryInsertSort.java)

[pairInsertionSort代码实现](../../../src/main/java/fanrui/study/sort/PairInsertSort.java)

- binaryInsertionSort和pairInsertionSort的实现请参考java的TimSort和DualPivotQuicksort实现

### [*back*](../)

### [*last*](../1.冒泡排序)

### [*next*](../3.选择排序)
