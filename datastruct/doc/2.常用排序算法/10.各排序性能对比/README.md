# 各排序性能对比

## 介绍

- 各排序算法时间复杂度、稳定性、空间复杂度比较

	![](./picture/各排序比较.jpeg)

## 测试数据测试各排序算法性能

- 生成的测试数据为**0~99**的int类型数据

	| 排序名称   | 10000个长度为500的数组  | 500个长度为10000的数组 |50个长度为100000的数组 |
	| :-------: | --------------------: | --------------------: | ------------------: |
	| 冒泡排序  | 2256ms | 44809ms | |
	| 选择排序  | 800ms | 11101ms | |
	| 插入排序  | 292ms | 4886ms | 49299ms |
	| 二分插入排序  | 301ms | 1097ms | 11779ms |
	| 双插入排序  | 200ms | 1451ms | 12360ms |
	| 归并排序  | 541ms | 471ms | 544ms |
	| 快速排序  | 222ms | 289ms | 856ms |
	| 3-Way排序  | 178ms | 165ms | 161ms |
	| DualPivotQuicksort  | 186ms | 167ms | 168ms |
	| 计数排序  | 56ms | 43ms | 33ms |

	- 由上述数据得出以下结论

		- 当数组长度不断变大时，O(n<sup>2</sup>)性能的排序算法明显比O(n log n)的排序算法差很多

		- 普通的插入排序比冒泡排序优秀很多

		- 当数组长度变大时，二分插入排序排序会比普通插入排序性能提高4倍，数组长度较短时，差别不是很大

		- 无论数组长度如何，双插入排序会比普通插入排序优秀一倍以上

		- 生成的测试数据范围不大时，3-way快排会比普通快排优秀很多

		- 生成的测试数据范围不大时，计数排序O(n)级别的时间复杂度太优秀了


- 生成的测试数据为**0~999999**的int类型数据

	| 排序名称   | 10000个长度为500的数组  | 500个长度为10000的数组 |
	| :-------: | --------------------: | --------------------: |
	| 冒泡排序  | 1771ms | 44423ms |
	| 选择排序  | 753ms | 11418ms |
	| 插入排序  | 297ms | 5063ms | 
	| 二分插入排序  | 294ms | 1161ms | 
	| 归并排序  | 434ms | 513ms | 
	| 快速排序  | 249ms | 328ms | 
	| 3-Way排序  | 256ms | 357ms | 
	| DualPivotQuicksort  | 274ms | 371ms | 
	| 计数排序  | 119131ms | 7286ms | 

	- 由上述数据得出以下结论

		- 生成的测试数据范围较大时，3-way快排 跟 普通快排 性能差不多，并没有起到优化的作用

		- 生成的测试数据范围较大时，计数排序已经废了

- 生成的测试数据为**0~999999**的int类型数据，且每隔1000个，数据是有序的（部分有序）

	- 比如：11,12,13,14,15,  6,7,8,9,10,  1,2,3,4,5,  21,22,23,24,25 就是每个5个，数据是有序的，部分有序

	| 排序名称   | 50个长度为100000的数组  | 
	| :-------: | --------------------: |
	| 归并排序  | 373ms | 
	| 快速排序  | 290ms | 
	| 3-Way排序  | 332ms | 
	| DualPivotQuicksort  | 196ms |

	- 由上述数据得出以下结论
	
		- 当数据部分有序时，DualPivotQuicksort 会使用归并排序merge的思想，大幅提高效率

## 代码实现

[排序性能对比测试代码](../../../src/test/java/fanrui/study/sort/SortPerformanceTest.java)



### [*back*](../)

### [*last*](../9.基数排序)

### [*next*](../11.剖析工业级排序的实现原理)
